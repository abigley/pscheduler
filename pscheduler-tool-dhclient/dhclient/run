#!/usr/bin/env python3

#
# Development Order #5:
#
# This is the meat and bones of the tool, where the actual desired
# commands or operation will be run. The results are then recorded
# and added to the 'results' JSON data, which will then be sent
# back to the test. Both system and api are able to be used here.
#

import datetime
import subprocess as sp
import json
import sys
import time

import pscheduler


# from stdin
input = pscheduler.json_load(exit_on_error=True)
# Take input from test spec
try:
    interface = input['test']['spec']['interface']
except KeyError:
    pscheduler.fail('Missing data in input')

timeout_iso = input['test']['spec'].get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds( pscheduler.iso8601_as_timedelta(timeout_iso) )
start_time = datetime.datetime.now()
succeeded = False
error = ''
diags = []

# Run the actual task here:

# IMPORTANT NOTE: This code puts the process to sleep until the
# scheduled start time has arrived.  It should be placed after all
# preparatory code has been executed and immediately before the tool
# is invoked (for plugins that run other programs) or any activity
# that does a measurement (for those that don't).

try:
    pscheduler.sleep_until(input['schedule']['start'])
except KeyError:
    # pscheduler.fail("Unable to find start time in input")
    pass

dhclient_release_args = ['sudo', 'dhclient', '-r',  interface]

diags.append(' '.join(dhclient_release_args))
status, stdout, stderr = pscheduler.run_program(dhclient_release_args)
print('status:', status, 'stdout:', stdout, 'stderr:', stderr)
if status != 0:
    pscheduler.fail("Unable to release current DHCP lease.")
diags.append(stderr)

# do some math and set a timeout for the run_program

dhclient_args = ['sudo', 'dhclient', '-v', interface]

diags.append(' '.join(dhclient_args))
start_time = datetime.datetime.now()
status, stdout, stderr = pscheduler.run_program(dhclient_args)
print('status:', status, 'stdout:', stdout, 'stderr:', stderr)
if status == 0:
    succeeded = True
    # get ip address
diags.append(stderr)
end_time = datetime.datetime.now()

# Organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
        'schema': 1,
        'time': pscheduler.timedelta_as_iso8601( end_time - start_time),
        'succeeded': succeeded
    },
    'error': error,
    'diags': '\n'.join(diags) }

pscheduler.succeed_json(results)


